1、redis热点key，单分片吞吐受限
2、也就是说会出现，数据库扣减失败，但是用户线程挂了，导致恢复量没有+1出现少卖；数据库扣减成功，但是为什么要清理回复标记
3、分布式锁都设置为过期时间+60min，可能会造成过期风暴，同一时刻大量key过期造成缓存雪崩

预扣减方案演化
1、恢复量+分布式锁
● 一致性都压在数据库扣减失败，恢复量一定会+1。但是用户数据库扣减失败后，线程挂了，就会导致redis多扣减，少卖现象。
● 分布式锁：
  ○ 锁分裂（锁还没有复制到从节点就暂时宕机，哨兵选取新节点当主节点，会造成锁唯一性改变）
  ○ 网络分区（不同网络分区可能产生相同的锁）
  ○ 单分片吞吐受限（热点key问题），解决：
  ○ Redlock 要求在多数节点获得锁才算成功，能缓解单点/复制延迟问题，但需要多个独立 Redis 实例，部署成本高，仍需合理 TTL 与时钟漂移容忍。
  ○ 社区对 Redlock 在强一致场景的充分性有争议；若你的临界区后续写入并不能基于“栅栏令牌（fencing token）”做版本校验，Redlock 也难以兜底。
注：建议。
● 若只是为了“库存扣减互斥”，优先用“无锁化”的并发控制：数据库条件更新（stock >= n）+唯一约束/乐观锁，结合幂等键，避免强依赖分布式锁。
● 若确实要锁：用具备强一致性的协调服务（ZooKeeper/etcd）+“栅栏令牌”，并让下游写路径校验令牌，拒绝过期令牌写入。仅用 Redis 锁请保持短 TTL、可自动续约（Redisson watchdog）、并设计“栅栏令牌”防乱序。

<span style="color:#e60000;">都压在数据库扣减失败，恢复量一定+1，+1失败需要进行补偿。</span>
2、恢复量+分布式锁+补偿
注：lua+redis+流水对账：性能与一致性要点
性能
条lua(校验一扣减/恢复一标记）在单分片下通常为亚毫秒到数毫秒级，瓶颈主要来自热点与网络rt;分段/分桶可
线性提升吞吐。
对账的一致性陷阱
读口径不同步：对账时db与redis读到的不是同一时刻的快照，会出现"假不一致。用水位戳/时间窗口对账，忽略
在途单。
重复修正/误修正：对账操作必须幂等（依据订单状态+幂等键）,否则可能回多/扣多".
延迟与抖动：对账周期越短，波动越大；建议以"最终状态单据"为准，对"处理中/未结算"延后核对。
跨分片聚合误差：分段计数需聚合，注意脚本/对账在相同hashtag语义或通过scan慎重汇总，避免漏段。
实践建议
以订单表"成功态作为权威口径；对账只把reds差值向d8既成事实"对齐；所有修正操作带幂等键和版本号（乐观
锁）.


3、Lua脚本+Redis实现库存秒杀（需要流水对账，确保redis和数据库一致性）

4、基于InventoryHint实现库存的热点扣减
3是先做Redis扣减，再做数据库扣减。


